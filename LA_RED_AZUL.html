
<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LA RED AZUL</title>
<style>
  html, body { background:#05060b; margin:0; height:100%; color:#d7eaff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
  #wrap { display:flex; align-items:center; justify-content:center; height:100%; }
  canvas { background:#02030a; border:1px solid #0ff; box-shadow:0 0 24px rgba(0,255,255,0.25), inset 0 0 24px rgba(0,180,255,0.15); outline:none; }
  .hud { position:absolute; top:8px; left:50%; transform:translateX(-50%); font-size:14px; letter-spacing:0.5px; color:#aeeaff; text-shadow:0 0 8px #00e5ff; }
  .btn { cursor:pointer; padding:10px 16px; border:1px solid #0ff; border-radius:10px; background:rgba(0,255,255,0.08); color:#bff4ff; text-shadow:0 0 8px #00e5ff; box-shadow:0 0 10px rgba(0,255,255,0.25); }
  .panel { position:absolute; bottom:12px; left:50%; transform:translateX(-50%); display:flex; gap:8px; }
  .msg { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:78%; max-width:780px; padding:18px 16px; background:rgba(2,12,24,0.92); border:1px solid #0ff; border-radius:14px; box-shadow:0 0 30px rgba(0,255,255,0.25); }
  .msg h2 { margin:0 0 8px 0; color:#7ee0ff; text-shadow:0 0 10px #00e5ff; font-weight:700; }
  .row { display:flex; flex-wrap:wrap; gap:8px; margin-top:12px; }
  .choice { flex:1 1 220px; border:1px solid #39f; border-radius:10px; padding:10px; background:rgba(0,60,120,0.15); cursor:pointer; }
  .choice:hover { background:rgba(0,160,255,0.15); }
  .inv { position:absolute; top:8px; left:12px; font-size:13px; color:#b6f3ff }
  .badge { display:inline-block; margin-right:8px; padding:2px 8px; border:1px solid #0ff; border-radius:999px; }
  .titleGlow { font-weight:900; font-size:44px; letter-spacing:2px; color:#8be9ff; text-shadow:0 0 10px #00e5ff, 0 0 30px #00d0ff, 0 0 60px #00b0ff; }
  .subGlow { color:#9cf; text-shadow:0 0 8px #00e5ff; }
  .focusHint { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; color:#7cf; opacity:0.0; transition:opacity .2s; }
  .focusHint.show { opacity:0.9; }
  .hud, .panel, .inv { pointer-events: none; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="900" height="560" tabindex="0"></canvas>
  <div class="hud" id="hud"></div>
  <div class="panel" id="panel"></div>
  <div class="inv" id="inv"></div>
  <div class="focusHint" id="focusHint"><div class="btn">Click sobre el juego para activar el teclado</div></div>
</div>

<script>
(() => {
'use strict';

/* ================================
   Núcleo: canvas + utilidades
===================================*/
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const HUD = document.getElementById('hud');
const PANEL = document.getElementById('panel');
const INV = document.getElementById('inv');
const FOCUS = document.getElementById('focusHint');

const W = canvas.width, H = canvas.height;
let last = 0;
const keys = new Set();
const justPressed = new Set();
const keyBlock = new Set(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ']);

document.addEventListener('keydown', (e) => {
  if (document.activeElement === canvas && keyBlock.has(e.key)) e.preventDefault();
});
canvas.addEventListener('keydown', (e) => { keys.add(e.key); justPressed.add(e.key); });
canvas.addEventListener('keyup', (e) => { keys.delete(e.key); });

const DIRS = { U:{dr:-1,dc:0}, D:{dr:1,dc:0}, L:{dr:0,dc:-1}, R:{dr:0,dc:1} };
const OPP  = { U:'D', D:'U', L:'R', R:'L' };

function isAligned(e){
  return Math.abs(e.r - Math.round(e.r)) < 0.08 &&
         Math.abs(e.c - Math.round(e.c)) < 0.08;
}
function canMoveRC(r, c, dir){
  const d = DIRS[dir];
  return !isWall(r + d.dr, c + d.dc);
}

/* ================================
   Estado global de la aventura
===================================*/
const state = {
  inventory: { chipAzul: false, acertijo: false },
  scene: 'menu',
  lives: 3,
  dotsLeft: 0
};

function setScene(name, data={}){
  currentScene = scenes[name];
  currentScene.enter?.(data);
  state.scene = name;
  flashFocusHint();
}
function flashFocusHint(){
  if (document.activeElement !== canvas) {
    FOCUS.classList.add('show');
    setTimeout(()=>FOCUS.classList.remove('show'), 1200);
  }
}

/* ================================
   Sistema de escenas
===================================*/
let currentScene;
const scenes = {};

/* ======= Escena: Menú ======= */
scenes.menu = {
  enter(){ HUD.textContent = ""; PANEL.innerHTML = ""; },
  update(dt){},
  draw(){
    drawNeonGrid('#082038', '#003b64');
    ctx.save();
    ctx.textAlign='center';
    ctx.shadowColor='#00e5ff';
    ctx.shadowBlur=24;
    ctx.fillStyle='#8be9ff';
    ctx.font='900 56px system-ui';
    ctx.fillText('LA RED AZUL', W/2, 180);
    ctx.shadowBlur=0;
    ctx.fillStyle='#9cf';
    ctx.font='400 18px system-ui';
    ctx.fillText('Aventura gráfica + Arcade Tron', W/2, 215);
    ctx.fillStyle='#bfe9ff';
    ctx.font='400 16px system-ui';
    ctx.fillText('Enter: Comenzar   •   Flechas: mover   •   Click: interactuar', W/2, 250);
    const bx = W/2 - 120, by = 300, bw = 240, bh = 50;
    drawButton(bx,by,bw,bh,'COMENZAR');
    hoverButton(bx,by,bw,bh, () => setScene('aventura'));
    ctx.restore();
  }
};

/* ======= Escena: Aventura ======= */
scenes.aventura = {
  enter(){
    HUD.textContent = "Sector: Vestíbulo de la Red — Explora con el mouse. Resuelve el acertijo y consigue el CHIP (arcade) para abrir el Núcleo.";
    PANEL.innerHTML = "";
  },
  update(dt){},
  draw(){
    drawNeonGrid('#06182a','#00243d');
    const orac =  {x:120,y:220,w:180,h:100, label:"Oráculo de Luz"};
    const arcade={x:360,y:320,w:180,h:100, label:"Terminal Tron"};
    const core  = {x:620,y:200,w:160,h:160, label:"Puerta del Núcleo"};

    drawModule(orac,  '#00e5ff');
    drawModule(arcade,'#ff00de');
    drawModule(core,  '#00ff8f');

    hoverBox(orac,   () => tip('Habla con el Oráculo (acertijo)'));
    hoverBox(arcade, () => tip('Ejecutar minijuego — conseguir CHIP AZUL'));
    hoverBox(core,   () => tip('Abrir Núcleo'));

    clickBox(orac,   () => abrirAcertijo());
    clickBox(arcade, () => setScene('arcade'));
    clickBox(core,   () => {
      if (state.inventory.acertijo && state.inventory.chipAzul) setScene('final');
      else speak("Núcleo Bloqueado", "Te faltan requisitos.",
                 ["Falta acertijo resuelto","Falta CHIP AZUL","Volver"], ()=>{});
    });

    renderInventario();
  }
};

function abrirAcertijo(onDone){
  const Q = [
    { p: "Tengo ciudades pero no casas, montañas pero no árboles y agua pero no peces. ¿Qué soy?",
      opts: ["Un mapa","Un circuito","Un holograma","Una base de datos"], ok: 0 },
    { p: "En la RED AZUL, ¿qué camino es más corto entre dos nodos?",
      opts: ["El de menor peso","El con más aristas","El más vistoso","El que evita el centro"], ok: 0 },
    { p: "Un byte son…", opts: ["8 bits","4 bits","16 bits","1 bit"], ok: 0 }
  ];
  let i = 0, aciertos = 0;
  const preguntar = () => {
    const q = Q[i];
    speak("Oráculo de Luz", q.p, q.opts, (pick)=>{
      if (pick === q.ok) aciertos++;
      i++;
      if (i < Q.length){ preguntar(); }
      else {
        if (aciertos === Q.length){
          state.inventory.acertijo = true;
          renderInventario();
          toast("Acceso concedido. Conocimiento integrado. (Acertijo ✓)");
        } else {
          toast(`Resultado: ${aciertos}/${Q.length}. El Oráculo espera más precisión.`);
        }
        onDone?.();
      }
    });
  };
  preguntar();
}

function abrirAcertijoArcade(){
  arcadePaused = true;
  abrirAcertijo(()=> { arcadePaused = false; });
}

/* ======= Escena: Arcade ======= */
const TILE = 24;
const COLS = 25;
const ROWS = 17;

let mapGrid, player, ghosts, dots;
let specialDots = {};
let arcadePaused = false;

function createMap(){
  const g = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>1));
  const carve = (r0,c0,r1,c1) => { for(let r=r0;r<=r1;r++) for(let c=c0;c<=c1;c++) g[r][c]=0; };
  carve(1,1,ROWS-2,COLS-2);
  for(let r=3;r<ROWS-3;r+=4){ for(let c=2;c<COLS-2;c++){ if (c%6!==0) g[r][c]=1; } }
  for(let c=4;c<COLS-4;c+=6){ for(let r=2;r<ROWS-2;r++){ if (r%6!==0) g[r][c]=1; } }
  g[(ROWS/2)|0][(COLS/2)|0]=0;

  dots = new Set();
  for(let r=1;r<ROWS-1;r++) for(let c=1;c<COLS-1;c++) if (g[r][c]===0) dots.add(r+','+c);

  specialDots = {};
  const sr = (ROWS/2)|0, sc = (COLS/2)|0;
  specialDots[ sr+','+(sc+2) ] = 'oraculo';

  state.dotsLeft = dots.size;
  return g;
}

function spawnArcade(){
  mapGrid = createMap();
  player = { r: (ROWS-2)|0, c: 1, spd: 50.0, dir: null, want: null };
  // Slightly different speeds to prevent sync
  ghosts = [
    { r:1,        c:COLS-2, spd:46, dir:'L', hue:300 },
    { r:1,        c:1,      spd:44, dir:'R', hue:200 },
    { r:ROWS-2,   c:COLS-2, spd:42, dir:'L', hue:50  }
  ];
}

function isWall(r,c){
  return r<0 || c<0 || r>=ROWS || c>=COLS || mapGrid[r][c]===1;
}

function handlePlayer(dt){
  if (keys.has('ArrowUp'))    player.want = 'U';
  else if (keys.has('ArrowDown'))  player.want = 'D';
  else if (keys.has('ArrowLeft'))  player.want = 'L';
  else if (keys.has('ArrowRight')) player.want = 'R';

  const step = (player.spd * dt) / TILE;
  const R = Math.round(player.r), C = Math.round(player.c);

  if (isAligned(player)){
    if (player.want && canMoveRC(R, C, player.want)) player.dir = player.want;
    if (!player.dir || !canMoveRC(R, C, player.dir)) { player.dir = null; player.r = R; player.c = C; }
  }

  if (player.dir){
    const d = DIRS[player.dir];
    if (!canMoveRC(Math.round(player.r), Math.round(player.c), player.dir)){ player.r = Math.round(player.r); player.c = Math.round(player.c); player.dir = null; }
    else { player.r += d.dr * step; player.c += d.dc * step; }
  }

  if (isAligned(player)){
    const key = R + ',' + C;
    if (dots.has(key)){
      dots.delete(key);
      state.dotsLeft = dots.size;
      if (specialDots[key] === 'oraculo'){ delete specialDots[key]; abrirAcertijoArcade(); }
    }
  }
}

function stepGhost(g, dt, reserved){
  const step = (g.spd * dt) / TILE;
  const GR = Math.round(g.r), GC = Math.round(g.c);

  if (isAligned(g)){
    // Candidate dirs (no reverse, no walls)
    let options = ['U','L','D','R'].filter(d=>{
      if (g.dir && d === OPP[g.dir]) return false;
      const dd = DIRS[d];
      return !isWall(GR + dd.dr, GC + dd.dc);
    });
    if (options.length === 0){
      options = ['U','L','D','R'].filter(d=>{
        const dd = DIRS[d];
        return !isWall(GR + dd.dr, GC + dd.dc);
      });
    }
    // Sort by chasing heuristic
    const PR = Math.round(player.r), PC = Math.round(player.c);
    options.sort((a,b)=>{
      const da = DIRS[a], db = DIRS[b];
      const ra = GR + da.dr, ca = GC + da.dc;
      const rb = GR + db.dr, cb = GC + db.dc;
      const A = Math.abs(PR - ra) + Math.abs(PC - ca);
      const B = Math.abs(PR - rb) + Math.abs(PC - cb);
      return A - B;
    });
    // Reservation: avoid picking a next cell already taken this frame
    let picked = null;
    for (const d of options){
      const dd = DIRS[d];
      const key = (GR + dd.dr) + ',' + (GC + dd.dc);
      if (!reserved.has(key)){ picked = d; reserved.add(key); break; }
    }
    // If all reserved, stay or allow reverse as last resort
    g.dir = picked ?? options[0] ?? g.dir ?? null;
  }

  if (g.dir && !isWall(Math.round(g.r) + DIRS[g.dir].dr,
                       Math.round(g.c) + DIRS[g.dir].dc)){
    g.r += DIRS[g.dir].dr * step;
    g.c += DIRS[g.dir].dc * step;
  } else {
    g.r = Math.round(g.r); g.c = Math.round(g.c);
  }
}

function checkLose(){
  const pr = Math.round(player.r), pc = Math.round(player.c);
  for (const g of ghosts){
    const gr = Math.round(g.r), gc = Math.round(g.c);
    if (gr === pr && gc === pc) return true;
  }
  return false;
}

function drawArcade(){
  const offX = (W - COLS*TILE)/2|0;
  const offY = (H - ROWS*TILE)/2|0;

  ctx.fillStyle = '#02030a';
  ctx.fillRect(0,0,W,H);

  ctx.save();
  ctx.translate(offX, offY);
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(mapGrid[r][c]===1){
        neonRect(c*TILE, r*TILE, TILE, TILE, '#00e5ff', 7);
      }
    }
  }
  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 12;
  ctx.fillStyle = '#aafaff';
  dots.forEach(k=>{
    const [r,c] = k.split(',').map(Number);
    ctx.beginPath();
    ctx.arc(c*TILE+TILE/2, r*TILE+TILE/2, 3, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.shadowBlur = 0;

  neonCircle(player.c*TILE+TILE/2, player.r*TILE+TILE/2, TILE*0.38, '#00ffbf', 10);
  for (const g of ghosts){
    neonCircle(g.c*TILE+TILE/2, g.r*TILE+TILE/2, TILE*0.38, `hsl(${g.hue} 100% 60%)`, 10);
  }
  ctx.restore();

  HUD.textContent = `Arcade Tron — Dots restantes: ${state.dotsLeft}   •   Vidas: ${state.lives}   •   ESC: volver`;
  INV.textContent = '';
  PANEL.innerHTML = '';
}

scenes.arcade = {
  enter(){ spawnArcade(); },
  update(dt){
    if (justPressed.has('Escape')) { justPressed.delete('Escape'); setScene('aventura'); return; }
    if (arcadePaused) return;

    handlePlayer(dt);

    // Separation: reserve next cells at intersections
    const reserved = new Set();
    const order = ghosts.slice().sort(()=>Math.random()-0.5); // avoid bias
    order.forEach(g=>stepGhost(g, dt, reserved));

    if (checkLose()){
      state.lives -= 1;
      if (state.lives <= 0){
        state.lives = 3;
        spawnArcade();
        toast("Has sido absorbido por los Centinelas. Reinicio del circuito.");
      } else {
        spawnArcade();
        toast("Impacto detectado. Vida -1.");
      }
    } else if (state.dotsLeft <= 0){
      state.inventory.chipAzul = true;
      renderInventario();
      // Pause and return to aventura only when OK is clicked.
      toast("¡CHIP AZUL obtenido!", ()=> setScene('aventura'));
      arcadePaused = true;
    }
  },
  draw(){ drawArcade(); }
};

/* ======= Escena: Final ======= */
scenes.final = {
  enter(){ HUD.textContent = ""; PANEL.innerHTML = ""; },
  update(dt){ if (justPressed.has('Enter')) { justPressed.delete('Enter'); setScene('menu'); } },
  draw(){
    drawNeonGrid('#06182a','#00243d');
    ctx.textAlign='center';
    ctx.fillStyle='#8be9ff';
    ctx.shadowColor='#00e5ff';
    ctx.shadowBlur=24;
    ctx.font='900 48px system-ui';
    ctx.fillText('NÚCLEO REACTIVADO', W/2, 210);
    ctx.shadowBlur=0;
    ctx.fillStyle='#bfe9ff';
    ctx.font='400 18px system-ui';
    ctx.fillText('Completaste LA RED AZUL — Enter para volver al menú', W/2, 250);
    for(let i=0;i<6;i++){
      neonCircle(W/2 + Math.sin(perf()*0.8+i)*140, 320+Math.cos(perf()*1.1+i)*20, 10, i%2? '#00e5ff' : '#00ff99', 12);
    }
  }
};

/* ================================
   UI auxiliares / dibujo
===================================*/
function perf(){ return performance.now()/1000; }
function drawNeonGrid(c1, c2){
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,c1); g.addColorStop(1,c2);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  ctx.save();
  ctx.strokeStyle='rgba(0,255,255,0.15)'; ctx.shadowColor='#00e5ff'; ctx.shadowBlur=12; ctx.lineWidth=1;
  const step=40;
  for(let x=0;x<=W;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<=H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.restore();
}
function neonRect(x,y,w,h,color,blur=12){ ctx.save(); ctx.strokeStyle=color; ctx.shadowColor=color; ctx.shadowBlur=blur; ctx.strokeRect(x+0.5,y+0.5,w-1,h-1); ctx.restore(); }
function neonCircle(x,y,r,color,blur=10){
  ctx.save(); ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
  ctx.shadowColor=color; ctx.shadowBlur=blur; ctx.fillStyle=color; ctx.globalAlpha=0.18; ctx.fill();
  ctx.globalAlpha=1; ctx.lineWidth=2; ctx.strokeStyle=color; ctx.stroke(); ctx.restore();
}
function drawButton(x,y,w,h,label){
  neonRect(x,y,w,h,'#00e5ff',14); ctx.fillStyle='rgba(0,255,255,0.08)'; ctx.fillRect(x,y,w,h);
  ctx.fillStyle='#bff4ff'; ctx.font='700 18px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(label, x+w/2, y+h/2);
}
function hoverButton(x,y,w,h, action){
  const mx = mouse.x, my = mouse.y;
  if (mx>=x && mx<=x+w && my>=y && my<=y+h){ canvas.style.cursor='pointer'; if (mouse.clicked){ mouse.clicked = false; action(); } }
}
function drawModule(box, color){
  neonRect(box.x, box.y, box.w, box.h, color, 12);
  ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(box.x, box.y, box.w, box.h);
  ctx.fillStyle = '#bfe9ff'; ctx.font = '600 16px system-ui'; ctx.textAlign='center'; ctx.fillText(box.label, box.x+box.w/2, box.y+box.h/2);
}
function hoverBox(box, tipFn){
  const {x,y} = mouse;
  if (x>=box.x && x<=box.x+box.w && y>=box.y && y<=box.y+box.h){ canvas.style.cursor='pointer'; tipFn?.(); }
}
function clickBox(box, action){
  const {x,y} = mouse;
  if (mouse.clicked && x>=box.x && x<=box.x+box.w && y>=box.y && y<=box.y+box.h) { mouse.clicked = false; action?.(); }
}
function tip(text){ HUD.textContent = text; }

function renderInventario(){
  const tags = [];
  tags.push(`<span class="badge">${state.inventory.acertijo? "Acertijo ✓": "Acertijo ✗"}</span>`);
  tags.push(`<span class="badge">${state.inventory.chipAzul? "CHIP AZUL ✓": "CHIP AZUL ✗"}</span>`);
  INV.innerHTML = 'Inventario: ' + tags.join('');
}

/* Modal helpers: pause arcade while any modal is open */
function toast(text, onOk){
  const div = document.createElement('div');
  div.className='msg';
  div.innerHTML = `<h2>Notificación</h2><div>${text}</div>
    <div class="row" style="justify-content:flex-end;margin-top:10px"><div class="btn">OK</div></div>`;
  document.body.appendChild(div);
  arcadePaused = true; // why: prevent action while modal visible
  div.querySelector('.btn').addEventListener('click', (e)=>{
    e.stopPropagation();
    div.remove();
    arcadePaused = false;
    onOk?.();
  });
}

function speak(title, body, choices, onPick){
  const div = document.createElement('div');
  div.className='msg';
  const opts = choices.map((c,i)=>`<div class="choice" data-i="${i}">${c}</div>`).join('');
  div.innerHTML = `<h2>${title}</h2><div>${body}</div><div class="row">${opts}</div>`;
  document.body.appendChild(div);
  if (state.scene==='arcade') arcadePaused = true;
  div.querySelectorAll('.choice').forEach(el=>{
    el.addEventListener('click', ()=>{
      const i = +el.dataset.i;
      div.remove();
      if (state.scene==='arcade') arcadePaused = false;
      onPick?.(i);
    });
  });
}

/* ================================
   Input: mouse
===================================*/
const mouse = { x: 0, y: 0, clicked: false };
function toCanvasCoords(e){
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width  / rect.width;
  const scaleY = canvas.height / rect.height;
  return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top)  * scaleY };
}
canvas.addEventListener('pointermove', (e)=>{ const p = toCanvasCoords(e); mouse.x = p.x; mouse.y = p.y; });
canvas.addEventListener('pointerdown', (e)=>{
  if (e.button !== 0) return;
  mouse.clicked = true;
  const p = toCanvasCoords(e); mouse.x = p.x; mouse.y = p.y;
  canvas.focus();
});
window.addEventListener('pointerup',    ()=> { mouse.clicked = false; });
window.addEventListener('pointercancel',()=> { mouse.clicked = false; });

/* ================================
   Bucle principal
===================================*/
function loop(ts){
  const t = ts*0.001;
  const dt = Math.min(0.05, t - last);
  last = t;
  canvas.style.cursor='default';
  currentScene.update?.(dt);
  currentScene.draw?.();
  justPressed.clear();
  requestAnimationFrame(loop);
}

/* ================================
   Arranque
===================================*/
setScene('menu');
requestAnimationFrame(loop);
canvas.addEventListener('click', ()=> canvas.focus());
document.body.addEventListener('click', ()=> FOCUS.classList.remove('show'));
window.addEventListener('keydown', (e)=>{
  if (document.activeElement !== canvas) return;
  if (state.scene==='menu' && e.key==='Enter'){ setScene('aventura'); }
});
renderInventario();
currentScene.draw?.();

})();
</script>
</body>
</html>
